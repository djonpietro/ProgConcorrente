Uso exclusivo de semáforos para implementação do padrão de
produtor consumidor

- Há uma únia thread produtora.
- O produtor enche o buffer todo.
- As threads consumidores removem elementos do buffer
- As threads, ao remover o elemento, verifica sua primalidade

int ehPrimo(long long int n) {
  int i;
  if (n<=1) return 0;
  if (n==2) return 1;
  if (n%2==0) return 0;
  for (i=3; i<sqrt(n)+1; i+=2)
    if(n%i==0) return 0;
  return 1;
}

- A saída do programa consiste de: a quantidade de primos encontrados e
a thread que contou mais primos.

Como dito, o problema implementa o padrão podutor consumidor, cujos requisitos
clássicos são:

- Produtor não pode preencher um buffer cheio. Sincronização por condição.

- As threads consumidoras não podem acessar o buffer vazio. Aqui deve ser usada
a sincronização por condição.

- Os elementos são inseridos em FIFO.

- elementos não podem ser sobrescritos.

- um elemento sendo removido por vez. Quando a thread for ler, é preciso evitar
a violação de aotmicidade da leitura.

Um requisito adicinal da aplicação é:

- Enquanto o produtor enche o buffer, nenhuma thread consumidora pode acessá-lo.
Logo é preciso implementar exclusão mútua para acesso ao buffer. Isso porque
o produtor preenche o buffer de uma vez.

